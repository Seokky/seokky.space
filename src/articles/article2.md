<header>
  <title>4 способа удалить дубликаты из массива</title>
  <description>4 способа удалить дубликаты из массива</description>
  <date>11.09.2021</date>
  <author>Максим Новерин</author>
</header>

## Использование конструктора Set()

Пожалуй, самый простой способ удалить дубликаты из массива - это использование конструктора Set(). Конструктор Set() принимает первым параметром итеративный объект и создает на его основе множество уникальных элементов. В случае отсутствия параметров создается пустое множество.
Итак, объявим и проинициализируем массив a, состоящий из шести элементов:
```
  const a = [1, 2, 3, 3, 2, 1];
```
Как мы видим, уникальными элементами здесь являются 1, 2 и 3. Давайте же обратимся к конструктору Set(), чтобы убедиться в этом:
```
  const uniqueSet = new Set(a);

  console.log(uniqueSet); // Set(3) {1, 2, 3};
```
Теперь, чтобы снова получить массив, нам достаточно использовать Array.prototype.from(), передав параметром наше множество.
```
  console.log(Array.from(uniqueSet)) // [1, 2, 3]
```
Производительность в среднем: ~0.008 ms.
<br><br>

## Использование Array.prototype.filter()

Решение с Array.prototype.filter() заключается в проходе циклом по исходному массиву со сравнением индексов на каждой итерации. Если быть точнее, мы сравниваем индекс итерации с результатом вызова Array.prototype.indexOf() для текущего элемента. Благодаря тому, что indexOf() останавливается на первом вхождении элемента (и всегда возвращает именно его индекс), дубликаты элемента попадать в результирующий массив не будут. Код будет выглядеть следующим образом:
```
  const a = [1, 2, 3, 3, 2, 1];

  const unique = a.filter((item, index) => index === a.indexOf(item));

  console.log(unique); // [1, 2, 3]
```
Производительность в среднем: ~0.06 ms.
<br><br>

## Использование Array.prototype.reduce()

В решении поставленной задачи оказывается полезным и метод прототипа массива reduce(). Здесь мы просто строим результирующий массив, руководствуясь тем, включает ли он уже элемент, который претендует на добавление в текущей итерации.
```
  const a = [1, 2, 3, 3, 2, 1];

  const unique = a.reduce(
    (uniqueArray, item) => uniqueArray.includes(item)
      ? uniqueArray
      : [...uniqueArray, item],
    [],
  )

  console.log(unique);
```
Производительность в среднем: ~0.065 ms. <br><br>
Следует отметить, что при необходимости в этом варианте можно избежать использования деструктуризации в пользу метода прототипа массива push(). Код получится немного более громоздким, но в то же время будет требовать меньше времени для выполнения. Откровенно говоря, незначительно меньше.
<br><br>

## Решение через Object.keys()

Решение основано на том, что в объекте не может быть двух одинаковых ключей. Пользуясь этим, мы проходим циклом по исходному массиву и записываем в заготовленный объект любое значение по ключу элемента итерации.
```
  const a = [1, 2, 3, 3, 2, 1];

  let uniqueKeys = {}

  for (let i = 0; i < a.length; i += 1) {
    uniqueKeys[a[i]] = true
  }
```
Затем преобразовываем ключи объекта в массив:
```
  console.log(Object.keys(uniqueKeys)) // [1, 2, 3]
```
Производительность в среднем: ~0.012 ms.
<br><br>

## Заключение

При желании, вариантов решения задачи удаления дубликатов из массива можно найти и больше. Вопрос лишь - зачем? Как видно, использование встроенного конструктора Set() показывает лучшую производительность, чем любое из "замудренных" решений. При этом, этот вариант является и самым лаконичным. С другой стороны, new Set() может не подойти для некоторых случаев, поэтому знать иные варианты решения проблемы в любом случае полезно!